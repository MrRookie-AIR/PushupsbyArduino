#include <TM1637Display.h>

// ===== Конфигурация =====
#define USE_DISPLAY        true
#define CLK_PIN            2
#define DIO_PIN            3
#define TRIG_PIN           4
#define ECHO_PIN           5
#define BUZZER_PIN         6
#define BUTTON_PIN         7

TM1637Display display(CLK_PIN, DIO_PIN);

// ===== Состояния автомата =====
enum State { SELECT_REPS, SELECT_REST, TRAINING, RESTING, DONE };
State currentState = SELECT_REPS;

// ===== Параметры тренировки =====
int totalReps           = 0;              // всего отжиманий
int restBetweenReps     = 0;              // пауза между повторениями (сек)
const int restBetweenSets = 10;           // пауза между сетами (сек)
const int setSize         = 20;           // размер одного сета

// ===== Счётчики =====
int repsLeft            = 0;              // остаток (включая штрафы)
int realPushupsDone     = 0;              // настоящие всего
int currentSetPushups   = 0;              // настоящие в текущем сете

// ===== Тайминги =====
unsigned long lastButtonPress = 0;
unsigned long lastRepTime     = 0;
unsigned long restStartTime   = 0;
int          lastDisplayedSecond = -9999;

// ===== Детект отжиманий =====
bool downDetected = false;
bool upDetected   = false;
unsigned long downTime = 0;

// ===== Кнопка =====
bool lastButtonState = HIGH;
bool isButtonJustPressed() {
  bool st = digitalRead(BUTTON_PIN);
  bool pressed = (lastButtonState == HIGH && st == LOW);
  lastButtonState = st;
  return pressed;
}

// ===== Звук =====
void beep(int times = 1, int freq = 2000, int dur = 100, int pauseMs = 100) {
  for (int i = 0; i < times; i++) {
    tone(BUZZER_PIN, freq, dur);
    delay(dur + pauseMs);
  }
}

// ===== Мигаем дисплеем =====
void blinkDisplay(int times, int value) {
  if (!USE_DISPLAY) return;
  for (int i = 0; i < times; i++) {
    display.clear();
    delay(200);
    display.showNumberDec(value, false);
    delay(200);
  }
}

// ===== Вывод имени состояния в Serial =====
void printStateName(State s) {
  switch (s) {
    case SELECT_REPS: Serial.print("SELECT_REPS"); break;
    case SELECT_REST: Serial.print("SELECT_REST"); break;
    case TRAINING:    Serial.print("TRAINING");    break;
    case RESTING:     Serial.print("RESTING");     break;
    case DONE:        Serial.print("DONE");        break;
  }
}

// ===== SETUP =====
void setup() {
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  if (USE_DISPLAY) {
    display.setBrightness(5);
    display.clear();
    display.showNumberDec(0, false);
  }

  Serial.begin(115200);
  Serial.println(F("=== SYSTEM START ==="));
}

// ===== LOOP =====
void loop() {
  unsigned long now = millis();

  // Раз в секунду печатаем состояние
  static unsigned long lastStatePrint = 0;
  if (now - lastStatePrint > 1000) {
    Serial.print(F("STATE: "));
    printStateName(currentState);
    Serial.print(F(" | repsLeft="));   Serial.print(repsLeft);
    Serial.print(F(" curSet="));        Serial.print(currentSetPushups);
    Serial.print(F(" totalReps="));     Serial.println(totalReps);
    lastStatePrint = now;
  }

  switch (currentState) {

    // === Выбор общего числа отжиманий ===
    case SELECT_REPS:
      if (isButtonJustPressed()) {
        totalReps += 10;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(totalReps, false);
        }
        lastButtonPress = now;
        Serial.print(F("Set totalReps -> "));
        Serial.println(totalReps);
      }
      else if (totalReps > 0 && now - lastButtonPress > 3000) {
        blinkDisplay(2, totalReps);
        currentState = SELECT_REST;
        lastButtonPress = now;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(0, false);
        }
        Serial.println(F("Switch to SELECT_REST"));
      }
      break;

    // === Выбор паузы между повторениями ===
    case SELECT_REST:
      if (isButtonJustPressed()) {
        restBetweenReps++;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(restBetweenReps, false);
        }
        lastButtonPress = now;
        Serial.print(F("Set restBetweenReps -> "));
        Serial.println(restBetweenReps);
      }
      else if (restBetweenReps > 0 && now - lastButtonPress > 3000) {
        blinkDisplay(3, restBetweenReps);
        currentState        = TRAINING;
        repsLeft            = totalReps;
        realPushupsDone     = 0;
        currentSetPushups   = 0;
        lastRepTime         = now;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(repsLeft, false);
        }
        Serial.println(F("Switch to TRAINING"));
      }
      break;

    // === Тренировка: детект репов + штрафы ===
    case TRAINING: {
      // УЗ-импульс
      digitalWrite(TRIG_PIN, LOW);
      delayMicroseconds(2);
      digitalWrite(TRIG_PIN, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG_PIN, LOW);

      long duration = pulseIn(ECHO_PIN, HIGH, 30000);
      float dist    = duration * 0.034 / 2.0;

      // Детект «вниз»
      if (!downDetected && dist > 0.5 && dist <= 4.0) {
        downDetected = true;
        downTime     = now;
        lastRepTime  = now;
        Serial.print(F("downDetected dist="));
        Serial.println(dist);
      }
      // Защита от «зависания»
      if (downDetected && now - downTime > 2000) {
        downDetected = upDetected = false;
        Serial.println(F("down timeout -> reset"));
      }
      // Детект «вверх»
      if (downDetected && !upDetected && dist >= 20.0 && now - downTime > 500) {
        upDetected = true;
        Serial.print(F("upDetected dist="));
        Serial.println(dist);
      }
      // Реп завершён
      if (downDetected && upDetected) {
        realPushupsDone++;
        currentSetPushups++;
        repsLeft--;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(repsLeft, false);
        }
        Serial.print(F("RepDone: realPushups="));
        Serial.print(realPushupsDone);
        Serial.print(F(" setPushups="));
        Serial.println(currentSetPushups);

        downDetected = upDetected = false;
        lastRepTime = now;

        // Переход в отдых после полного сета
        if (currentSetPushups >= setSize && repsLeft > 0) {
          Serial.print(F(">>> ENTER REST MODE <<<  setPushups="));
          Serial.print(currentSetPushups);
          Serial.print(F(" repsLeft="));
          Serial.println(repsLeft);

          restStartTime       = now;
          lastDisplayedSecond = -9999;
          currentState        = RESTING;
        }
        // Завершили все отжимания
        if (repsLeft <= 0) {
          currentState = DONE;
          Serial.println(F(">>> ALL DONE <<<"));
        }
      }

      // Штраф за бездействие
      if ((now - lastRepTime) > restBetweenReps * 1000UL && repsLeft > 0) {
        repsLeft++;
        Serial.println(F("Penalty: +1 repLeft"));
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(repsLeft, false);
        }
        beep(1, 1000, 200);
        lastRepTime = now;
      }
      break;
    }

    // === Отдых (неблокирующий отчёт) ===
    case RESTING: {
      unsigned long elapsed = now - restStartTime;
      int secondsLeft = restBetweenSets - (elapsed / 1000);

      // Первый вход в RESTING?
      if (lastDisplayedSecond == -9999) {
        Serial.print(F("REST START, secondsLeft="));
        Serial.println(secondsLeft);
      }
      // Обновление экрана при изменении
      if (secondsLeft != lastDisplayedSecond && secondsLeft >= 0) {
        Serial.print(F("RESTING: "));
        Serial.print(secondsLeft);
        Serial.println(F(" sec left"));
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(secondsLeft, false);
        }
        lastDisplayedSecond = secondsLeft;
      }
      // Выход из отдыха
      if (elapsed >= restBetweenSets * 1000UL) {
        Serial.println(F("REST FINISHED -> back to TRAINING"));
        currentSetPushups = 0;
        currentState      = TRAINING;
        if (USE_DISPLAY) {
          display.clear();
          display.showNumberDec(repsLeft, false);
        }
      }
      break;
    }

    // === Завершение и мигание «dOnE» ===
    case DONE: {
      // Массив сегментов для «dOnE»
      const uint8_t segs_DOnE[4] = {
        0b1001111, // «d»
        0b0001110, // «o»
        0b0100001, // «n»
        0b0101111  // «E»
      };
      unsigned long t0 = millis();
      // Мигание 3 секунды
      while (millis() - t0 < 3000) {
        if (USE_DISPLAY) {
          display.setSegments(segs_DOnE, 4);
        }
        delay(500);
        if (USE_DISPLAY) {
          display.clear();
        }
        delay(500);
      }
      // Сброс и переход в SELECT_REPS
      totalReps         = 0;
      restBetweenReps   = 0;
      realPushupsDone   = 0;
      currentSetPushups = 0;
      currentState      = SELECT_REPS;
      if (USE_DISPLAY) {
        display.clear();
        display.showNumberDec(0, false);
      }
      Serial.println(F("RESET -> SELECT_REPS"));
      break;
    }
  }

  delay(20);  // стабилизация цикла
}
